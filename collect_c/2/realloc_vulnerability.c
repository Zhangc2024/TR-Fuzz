/*******************************************************************************
*
* Program: Realloc memory security vulnernability
* 
* Description: Demonstrates a security vulnerability when using realloc where 
* realloc does not delete or clear memory of sensitive data. If realloc cannot 
* reallocate enough space in the current location in memory, perhaps because 
* other data is located directly after what is being reallocated, it copies the 
* data into a new place in memory entirely. The problem is that it leaves the 
* data in the old memory location, which could contain sensitive data such as 
* passwords, and now our program does not even "control" this data anymore!
*
* YouTube Lesson: https://www.youtube.com/watch?v=_Ns0CWEoRio
*
* Author: Kevin Browne @ https://portfoliocourses.com
*
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*

  A visualization of the state of memory at the end of the program...

  var:  other_ptr     password2     password1 
  data: a b c 1 2 3   x y z 7 8 9   a b ...
  mem:  0 1 2 3 4 5 6 7 8 9 a b c d e f ...

*/

int main(void)
{
  char *password1;
  char *password2;
  char *other_ptr;

  // store two passwords in dynamically allocated memory on the heap
  password1 = malloc(7 * sizeof(char));
  password2 = malloc(7 * sizeof(char));
  strcpy(password1, "abc123");
  strcpy(password2, "xyz789");

  // print out both addresses, notice password2 is stored right after password1
  printf("p1 addr: %p\np2 addr: %p\n", password1, password2);
  printf("p1 addr: %d\np2 addr: %d\n", (int) password1, (int) password2);
  printf("\n");

  // if we print out characters starting from password1 and beyond we notice 
  // we'll print out password2 too!
  for (int i = 0; i < 100; i++) printf("%c", password1[i]);
  printf("\n\n");

  // keep a pointer to password1's original location in memory
  other_ptr = password1;

  // When we call realloc to reallocate space for password1, it can't simply 
  // enlarge the existing space in memory because password2 is stored directly
  // after password1. Instead, it allocates space in a new position in memory 
  // and copies the data to this new position (which will actually be right 
  // after password2). The problem is that the original data for password1, 
  // which is sensitive information, remains in the original spot in memory!
  // And at the same time, our program doesn't really "control" this space 
  // anymore either, we only have a pointer to it because we created one 
  // above specifically. This is vulnerable to an attack that can access this 
  // memory and find the sensitive information.  
  password1 = realloc(password1, 20 * sizeof(char));

  // print out both addresses, and notice the password1 address has changed
  printf("p1 addr: %p\np2 addr: %p\n", password1, password2);
  printf("p1 addr: %d\np2 addr: %d\n", (int) password1, (int) password2);
  printf("\n");

  // password1 stores the password the same as before
  printf("password1: %s\n\n", password1);

  // but the old memory address still contains the password too!
  printf("other ptr addr: %d\n", (int) other_ptr);
  printf("other ptr string: %s\n\n", other_ptr);

  // if we print out characters in memory starting from the old password1 
  // location in memory, we can see that password1's data is in memory twice!
  for (int i = 0; i < 100; i++)
    printf("%c", other_ptr[i]);
  printf("\n");

  return 0;
}
